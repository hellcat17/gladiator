{% from "util/type_reference.jinja2" import lowlevel_typeref, lowlevel_params, highlevel_typeref, highlevel_params %}
{% from "util/conversion.jinja2" import convert_params, convert_retval %}
{% from "util/resolve.jinja2" import resolve %}

{%- macro make_loader_name(level) -%}
	{{ (options.loader_or_class_name_template or "load_{api}_{major}{minor}_functions").format(api=level.api.value, major=level.version.major, minor=level.version.minor) }}
{%- endmacro -%}

{%- macro resolve_underlying_func(name) -%}
	{{ resolve(constants.detail_namespace, "_" + name) }}
{%- endmacro -%}

{% for level in levels %}

{# procedure type definitions and storage #}

namespace {{ constants.detail_namespace }} {

{% for command in level.commands %}
	{% set f = command.original %}
	using _proc_{{ f.name }} = std::add_pointer<{{ lowlevel_typeref(f.return_type) }}({{ lowlevel_params(f.params) }})>::type;
	_proc_{{ f.name }} _{{ f.name }} = nullptr;
{% endfor %}

using loadProcAddressFunc = std::add_pointer<void*(const char*)>::type;

}

{# loaders per level #}

namespace {{ options.loader_or_class_namespace or constants.default_namespace }} {

{% if level.is_merged %}
	{% set loaderName = options.loader_or_class_name_template or "load_functions" %}
{% else %}
	{% set loaderName = make_loader_name(level) %}
{% endif %}

bool {{ loaderName }}(const {{ resolve(constants.detail_namespace, "loadProcAddressFunc") }} load) {

{# load the functions of the previous version #}
{% if loop.previtem %}
	{{ make_loader_name(loop.previtem) }}(load);
{% endif %}

{% for command in level.commands %}
	{% set name = command.original.name %}
	{% set symbol = resolve_underlying_func(name) %}
	{% set type = resolve(constants.detail_namespace, "_proc_" + name) %}
	if (({{ symbol }} = ({{ type }})(load("{{ name }}"))) == nullptr) return false;
{% endfor %}

return true;

}

{# type-safe wrappers for each command #}

{% for command in level.commands %}
	{% set underlying = resolve_underlying_func(command.original.name) %}

	{% if command.type_ == CommandType.DEFAULT %}
		{% set impl =  command.implementation%}
		{% set rettype = highlevel_typeref(impl.return_type) %}
		{% set params = highlevel_params(impl.params) %}
		{% set returns_void = impl.return_type.low_level == "void" and not impl.return_type.back_modifiers %}

		auto {{ command.name }}({{ params }}) -> {{ rettype }} {
			{% if not returns_void %}const auto {{ impl.retval_temporary }} = {% endif -%}
			{{ underlying }}({{ convert_params(impl.param_conversions) }});

			{% if not returns_void %}
				return {{ convert_retval(impl) }};
			{% endif %}
		}
	{% endif %}
{% endfor %}

}

{% endfor %}
